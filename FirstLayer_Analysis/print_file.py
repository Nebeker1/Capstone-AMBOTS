# Description: The file can take a GCode file as input and print the GCode file on the printer,
#   allowing user to select if they wish to continue after first layer.
# Author: Capstone Team 9
# Date: Spring 2024

from ../BedMesh_Analysis/duet_http import send_gcode_command, get_duet_status, upload_file, get_reply_sequence, recieve_reply
import sys
import time
import os
import ctypes

DUET_IP = '192.168.0.136'

def save_heightmap(duet_ip, save_path):
	file_path = os.path.join(save_path, 'heightmap_print.csv')
	download_file(duet_ip, '/sys/IR_Mesh.csv', file_path)

def write_new_files(lines, index, comments_index, first_layer_filename, remaining_filename):
    try:
        first_layer_file = open(first_layer_filename, 'w')
        first_layer_file.writelines(lines[:index])
        first_layer_file.writelines(lines[comments_index:])
        remaining_file = open(remaining_filename, 'w')
        remaining_file.writelines(lines[index:])
    except:
        print("ERROR: Could not write new files.")
        sys.exit(0)

def get_file_info(filename):
    try:
        file = open(filename, 'r')
    except:
        print("ERROR: Could not find file with name <" + filename + ">.")
        sys.exit(0)

    lines = file.readlines()
    for index, line in enumerate(lines):
        if "G32 K2" in line:
            break
    for comments_index, line in enumerate(lines):
        if "; * * * * * * * * * * * *   END_GCODE_END" in line:
            break
    
    return lines, index+1, comments_index

if __name__ == "__main__":
    filename = ""

    try:
        filename = sys.argv[1]
    except:
        print("ERROR: No filename entered.")
        sys.exit(0)

    # Split file into two files.
    lines, index, comments_index = get_file_info(filename)
    pre, ext = os.path.splitext(filename)
    first_layer_filename = pre + "_first_layer" + ext
    remaining_filename = pre + "_remaining" + ext
    write_new_files(lines, index, comments_index, first_layer_filename, remaining_filename)
    
    #Send first layer to Duet
    file = os.path.join(os.path.dirname(__file__), first_layer_filename)
    dst_filepath = '/gcodes/' + first_layer_filename
    upload_file(DUET_IP, file, dst_filepath)

    # Run first layer file
    print("Running first layer...")
    run_gcode = f"M98 P\"{dst_filepath}\""
    send_gcode_command(DUET_IP, run_gcode)

    #Timeout until first layer is printed, also save the height map generated by the first layer scan.
    time.sleep(5) # wait 5 seconds to allow for printer to recieve command to start print
    last_seq = get_reply_sequence(DUET_IP)
    current_seq = last_seq
    response = ''
    while True:
        time.sleep(1)
        current_seq = get_reply_sequence(DUET_IP)
        if current_seq > last_seq:
            last_seq = current_seq
            response = recieve_reply(DUET_IP)
            print(response)
            if 'Error' in response:
                print("ERROR in response")
                sys.exit(0)
        if (get_duet_status(DUET_IP).get('status', {}) == 'I'):
            print("First Layer Complete.")
            break
    
    save_path = os.path.join(os.path.dirname(__file__), f'heightmaps/{datetime.datetime.now().strftime("%Y-%m-%d")}')
    save_heightmap(DUET_IP, save_path)

    # Ask user if they want to continue with the print, don't continue if 'no'
    user_choice = ctypes.windll.user32.MessageBoxW(0, "Do you wish to continue the print?", "Duet3D Print", 4)
    if (user_choice != 6):
        print("Aborting print...")
        cancel_command = "M98 P\"END_GCODE.g\""
        send_gcode_command(DUET_IP, cancel_command)
        time.sleep(5)
        sys.exit(0)

    #Send remaining print to Duet
    print("Continuing print...")
    file = os.path.join(os.path.dirname(__file__), remaining_filename)
    dst_filepath = '/gcodes/' + remaining_filename
    upload_file(DUET_IP, file, dst_filepath)

    # Run remaining print file
    run_gcode = f"M98 P\"{dst_filepath}\""
    send_gcode_command(DUET_IP, run_gcode)
